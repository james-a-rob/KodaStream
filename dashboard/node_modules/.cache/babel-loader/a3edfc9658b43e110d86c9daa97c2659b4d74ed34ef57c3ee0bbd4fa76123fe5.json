{"ast":null,"code":"import { parseFilterArgs, parseQueryArgs, functionalUpdate, noop, hashQueryKey, partialMatchKey, hashQueryKeyByOptions } from './utils.mjs';\nimport { QueryCache } from './queryCache.mjs';\nimport { MutationCache } from './mutationCache.mjs';\nimport { focusManager } from './focusManager.mjs';\nimport { onlineManager } from './onlineManager.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior.mjs';\nimport { defaultLogger } from './logger.mjs';\n\n// CLASS\nclass QueryClient {\n  constructor(config = {}) {\n    this.queryCache = config.queryCache || new QueryCache();\n    this.mutationCache = config.mutationCache || new MutationCache();\n    this.logger = config.logger || defaultLogger;\n    this.defaultOptions = config.defaultOptions || {};\n    this.queryDefaults = [];\n    this.mutationDefaults = [];\n    this.mountCount = 0;\n    if (process.env.NODE_ENV !== 'production' && config.logger) {\n      this.logger.error(\"Passing a custom logger has been deprecated and will be removed in the next major version.\");\n    }\n  }\n  mount() {\n    this.mountCount++;\n    if (this.mountCount !== 1) return;\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations();\n        this.queryCache.onFocus();\n      }\n    });\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations();\n        this.queryCache.onOnline();\n      }\n    });\n  }\n  unmount() {\n    var _this$unsubscribeFocu, _this$unsubscribeOnli;\n    this.mountCount--;\n    if (this.mountCount !== 0) return;\n    (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);\n    this.unsubscribeFocus = undefined;\n    (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);\n    this.unsubscribeOnline = undefined;\n  }\n  isFetching(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    filters.fetchStatus = 'fetching';\n    return this.queryCache.findAll(filters).length;\n  }\n  isMutating(filters) {\n    return this.mutationCache.findAll({\n      ...filters,\n      fetching: true\n    }).length;\n  }\n  getQueryData(queryKey, filters) {\n    var _this$queryCache$find;\n    return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;\n  }\n  ensureQueryData(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    const cachedData = this.getQueryData(parsedOptions.queryKey);\n    return cachedData ? Promise.resolve(cachedData) : this.fetchQuery(parsedOptions);\n  }\n  getQueriesData(queryKeyOrFilters) {\n    return this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey,\n      state\n    }) => {\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n  setQueryData(queryKey, updater, options) {\n    const query = this.queryCache.find(queryKey);\n    const prevData = query == null ? void 0 : query.state.data;\n    const data = functionalUpdate(updater, prevData);\n    if (typeof data === 'undefined') {\n      return undefined;\n    }\n    const parsedOptions = parseQueryArgs(queryKey);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions);\n    return this.queryCache.build(this, defaultedOptions).setData(data, {\n      ...options,\n      manual: true\n    });\n  }\n  setQueriesData(queryKeyOrFilters, updater, options) {\n    return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey\n    }) => [queryKey, this.setQueryData(queryKey, updater, options)]));\n  }\n  getQueryState(queryKey, filters) {\n    var _this$queryCache$find2;\n    return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;\n  }\n  removeQueries(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    const queryCache = this.queryCache;\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        queryCache.remove(query);\n      });\n    });\n  }\n  resetQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const queryCache = this.queryCache;\n    const refetchFilters = {\n      type: 'active',\n      ...filters\n    };\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        query.reset();\n      });\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n  cancelQueries(arg1, arg2, arg3) {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true;\n    }\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map(query => query.cancel(cancelOptions)));\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n  invalidateQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    return notifyManager.batch(() => {\n      var _ref, _filters$refetchType;\n      this.queryCache.findAll(filters).forEach(query => {\n        query.invalidate();\n      });\n      if (filters.refetchType === 'none') {\n        return Promise.resolve();\n      }\n      const refetchFilters = {\n        ...filters,\n        type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : 'active'\n      };\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n  refetchQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter(query => !query.isDisabled()).map(query => {\n      var _options$cancelRefetc;\n      return query.fetch(undefined, {\n        ...options,\n        cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,\n        meta: {\n          refetchPage: filters.refetchPage\n        }\n      });\n    }));\n    let promise = Promise.all(promises).then(noop);\n    if (!(options != null && options.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n    return promise;\n  }\n  fetchQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions); // https://github.com/tannerlinsley/react-query/issues/652\n\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false;\n    }\n    const query = this.queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n  prefetchQuery(arg1, arg2, arg3) {\n    return this.fetchQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n  fetchInfiniteQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    parsedOptions.behavior = infiniteQueryBehavior();\n    return this.fetchQuery(parsedOptions);\n  }\n  prefetchInfiniteQuery(arg1, arg2, arg3) {\n    return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n  resumePausedMutations() {\n    return this.mutationCache.resumePausedMutations();\n  }\n  getQueryCache() {\n    return this.queryCache;\n  }\n  getMutationCache() {\n    return this.mutationCache;\n  }\n  getLogger() {\n    return this.logger;\n  }\n  getDefaultOptions() {\n    return this.defaultOptions;\n  }\n  setDefaultOptions(options) {\n    this.defaultOptions = options;\n  }\n  setQueryDefaults(queryKey, options) {\n    const result = this.queryDefaults.find(x => hashQueryKey(queryKey) === hashQueryKey(x.queryKey));\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.queryDefaults.push({\n        queryKey,\n        defaultOptions: options\n      });\n    }\n  }\n  getQueryDefaults(queryKey) {\n    if (!queryKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n    const firstMatchingDefaults = this.queryDefaults.find(x => partialMatchKey(queryKey, x.queryKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.queryDefaults.filter(x => partialMatchKey(queryKey, x.queryKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\"[QueryClient] Several query defaults match with key '\" + JSON.stringify(queryKey) + \"'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.\");\n      }\n    }\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n  setMutationDefaults(mutationKey, options) {\n    const result = this.mutationDefaults.find(x => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey));\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.mutationDefaults.push({\n        mutationKey,\n        defaultOptions: options\n      });\n    }\n  }\n  getMutationDefaults(mutationKey) {\n    if (!mutationKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n    const firstMatchingDefaults = this.mutationDefaults.find(x => partialMatchKey(mutationKey, x.mutationKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.mutationDefaults.filter(x => partialMatchKey(mutationKey, x.mutationKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\"[QueryClient] Several mutation defaults match with key '\" + JSON.stringify(mutationKey) + \"'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.\");\n      }\n    }\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n  defaultQueryOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n    const defaultedOptions = {\n      ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);\n    } // dependent default values\n\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== 'always';\n    }\n    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;\n    }\n    return defaultedOptions;\n  }\n  defaultMutationOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n    return {\n      ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n  clear() {\n    this.queryCache.clear();\n    this.mutationCache.clear();\n  }\n}\nexport { QueryClient };","map":{"version":3,"names":["QueryClient","constructor","config","queryCache","QueryCache","mutationCache","MutationCache","logger","defaultLogger","defaultOptions","queryDefaults","mutationDefaults","mountCount","process","env","NODE_ENV","error","mount","unsubscribeFocus","focusManager","subscribe","isFocused","resumePausedMutations","onFocus","unsubscribeOnline","onlineManager","isOnline","onOnline","unmount","_this$unsubscribeFocu","_this$unsubscribeOnli","call","undefined","isFetching","arg1","arg2","filters","parseFilterArgs","fetchStatus","findAll","length","isMutating","fetching","getQueryData","queryKey","_this$queryCache$find","find","state","data","ensureQueryData","arg3","parsedOptions","parseQueryArgs","cachedData","Promise","resolve","fetchQuery","getQueriesData","queryKeyOrFilters","getQueryCache","map","setQueryData","updater","options","query","prevData","functionalUpdate","defaultedOptions","defaultQueryOptions","build","setData","manual","setQueriesData","notifyManager","batch","getQueryState","_this$queryCache$find2","removeQueries","forEach","remove","resetQueries","refetchFilters","type","reset","refetchQueries","cancelQueries","cancelOptions","revert","promises","cancel","all","then","noop","catch","invalidateQueries","_ref","_filters$refetchType","invalidate","refetchType","filter","isDisabled","_options$cancelRefetc","fetch","cancelRefetch","meta","refetchPage","promise","throwOnError","retry","isStaleByTime","staleTime","prefetchQuery","fetchInfiniteQuery","behavior","infiniteQueryBehavior","prefetchInfiniteQuery","getMutationCache","getLogger","getDefaultOptions","setDefaultOptions","setQueryDefaults","result","x","hashQueryKey","push","getQueryDefaults","firstMatchingDefaults","partialMatchKey","matchingDefaults","JSON","stringify","setMutationDefaults","mutationKey","getMutationDefaults","_defaulted","queries","queryHash","hashQueryKeyByOptions","refetchOnReconnect","networkMode","useErrorBoundary","suspense","defaultMutationOptions","mutations","clear"],"sources":["/Users/jamesrobertson/Code/air/dashboard/node_modules/@tanstack/query-core/src/queryClient.ts"],"sourcesContent":["import {\n  functionalUpdate,\n  hashQueryKey,\n  hashQueryKeyByOptions,\n  noop,\n  parseFilterArgs,\n  parseQueryArgs,\n  partialMatchKey,\n} from './utils'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\nimport { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { notifyManager } from './notifyManager'\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior'\nimport { defaultLogger } from './logger'\nimport type { CancelOptions, DefaultedQueryObserverOptions } from './types'\nimport type { Logger } from './logger'\nimport type { QueryState } from './query'\nimport type {\n  DefaultOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationKey,\n  MutationObserverOptions,\n  MutationOptions,\n  QueryClientConfig,\n  QueryFunction,\n  QueryKey,\n  QueryObserverOptions,\n  QueryOptions,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  ResetQueryFilters,\n  SetDataOptions,\n  WithRequired,\n} from './types'\nimport type { MutationFilters, QueryFilters, Updater } from './utils'\n\n// TYPES\n\ninterface QueryDefaults {\n  queryKey: QueryKey\n  defaultOptions: QueryOptions<any, any, any>\n}\n\ninterface MutationDefaults {\n  mutationKey: MutationKey\n  defaultOptions: MutationOptions<any, any, any, any>\n}\n\n// CLASS\n\nexport class QueryClient {\n  private queryCache: QueryCache\n  private mutationCache: MutationCache\n  private logger: Logger\n  private defaultOptions: DefaultOptions\n  private queryDefaults: QueryDefaults[]\n  private mutationDefaults: MutationDefaults[]\n  private mountCount: number\n  private unsubscribeFocus?: () => void\n  private unsubscribeOnline?: () => void\n\n  constructor(config: QueryClientConfig = {}) {\n    this.queryCache = config.queryCache || new QueryCache()\n    this.mutationCache = config.mutationCache || new MutationCache()\n    this.logger = config.logger || defaultLogger\n    this.defaultOptions = config.defaultOptions || {}\n    this.queryDefaults = []\n    this.mutationDefaults = []\n    this.mountCount = 0\n\n    if (process.env.NODE_ENV !== 'production' && config.logger) {\n      this.logger.error(\n        `Passing a custom logger has been deprecated and will be removed in the next major version.`,\n      )\n    }\n  }\n\n  mount(): void {\n    this.mountCount++\n    if (this.mountCount !== 1) return\n\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations()\n        this.queryCache.onFocus()\n      }\n    })\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations()\n        this.queryCache.onOnline()\n      }\n    })\n  }\n\n  unmount(): void {\n    this.mountCount--\n    if (this.mountCount !== 0) return\n\n    this.unsubscribeFocus?.()\n    this.unsubscribeFocus = undefined\n\n    this.unsubscribeOnline?.()\n    this.unsubscribeOnline = undefined\n  }\n\n  isFetching(filters?: QueryFilters): number\n  isFetching(queryKey?: QueryKey, filters?: QueryFilters): number\n  isFetching(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): number {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    filters.fetchStatus = 'fetching'\n    return this.queryCache.findAll(filters).length\n  }\n\n  isMutating(filters?: MutationFilters): number {\n    return this.mutationCache.findAll({ ...filters, fetching: true }).length\n  }\n\n  getQueryData<TQueryFnData = unknown>(\n    queryKey: QueryKey,\n    filters?: QueryFilters,\n  ): TQueryFnData | undefined {\n    return this.queryCache.find<TQueryFnData>(queryKey, filters)?.state.data\n  }\n\n  ensureQueryData<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: WithRequired<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey'\n    >,\n  ): Promise<TData>\n  ensureQueryData<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: Omit<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey'\n    >,\n  ): Promise<TData>\n  ensureQueryData<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: Omit<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey' | 'queryFn'\n    >,\n  ): Promise<TData>\n  ensureQueryData<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1:\n      | TQueryKey\n      | WithRequired<\n          FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n          'queryKey'\n        >,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    const cachedData = this.getQueryData<TData>(parsedOptions.queryKey!)\n\n    return cachedData\n      ? Promise.resolve(cachedData)\n      : this.fetchQuery(parsedOptions)\n  }\n\n  getQueriesData<TQueryFnData = unknown>(\n    queryKey: QueryKey,\n  ): [QueryKey, TQueryFnData | undefined][]\n  getQueriesData<TQueryFnData = unknown>(\n    filters: QueryFilters,\n  ): [QueryKey, TQueryFnData | undefined][]\n  getQueriesData<TQueryFnData = unknown>(\n    queryKeyOrFilters: QueryKey | QueryFilters,\n  ): [QueryKey, TQueryFnData | undefined][] {\n    return this.getQueryCache()\n      .findAll(queryKeyOrFilters)\n      .map(({ queryKey, state }) => {\n        const data = state.data as TQueryFnData | undefined\n        return [queryKey, data]\n      })\n  }\n\n  setQueryData<TQueryFnData>(\n    queryKey: QueryKey,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): TQueryFnData | undefined {\n    const query = this.queryCache.find<TQueryFnData>(queryKey)\n    const prevData = query?.state.data\n    const data = functionalUpdate(updater, prevData)\n\n    if (typeof data === 'undefined') {\n      return undefined\n    }\n\n    const parsedOptions = parseQueryArgs(queryKey)\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions)\n    return this.queryCache\n      .build(this, defaultedOptions)\n      .setData(data, { ...options, manual: true })\n  }\n\n  setQueriesData<TQueryFnData>(\n    queryKey: QueryKey,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): [QueryKey, TQueryFnData | undefined][]\n\n  setQueriesData<TQueryFnData>(\n    filters: QueryFilters,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): [QueryKey, TQueryFnData | undefined][]\n\n  setQueriesData<TQueryFnData>(\n    queryKeyOrFilters: QueryKey | QueryFilters,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): [QueryKey, TQueryFnData | undefined][] {\n    return notifyManager.batch(() =>\n      this.getQueryCache()\n        .findAll(queryKeyOrFilters)\n        .map(({ queryKey }) => [\n          queryKey,\n          this.setQueryData<TQueryFnData>(queryKey, updater, options),\n        ]),\n    )\n  }\n\n  getQueryState<TQueryFnData = unknown, TError = undefined>(\n    queryKey: QueryKey,\n    filters?: QueryFilters,\n  ): QueryState<TQueryFnData, TError> | undefined {\n    return this.queryCache.find<TQueryFnData, TError>(queryKey, filters)?.state\n  }\n\n  removeQueries(filters?: QueryFilters): void\n  removeQueries(queryKey?: QueryKey, filters?: QueryFilters): void\n  removeQueries(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): void {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    const queryCache = this.queryCache\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query)\n      })\n    })\n  }\n\n  resetQueries<TPageData = unknown>(\n    filters?: ResetQueryFilters<TPageData>,\n    options?: ResetOptions,\n  ): Promise<void>\n  resetQueries<TPageData = unknown>(\n    queryKey?: QueryKey,\n    filters?: ResetQueryFilters<TPageData>,\n    options?: ResetOptions,\n  ): Promise<void>\n  resetQueries(\n    arg1?: QueryKey | ResetQueryFilters,\n    arg2?: ResetQueryFilters | ResetOptions,\n    arg3?: ResetOptions,\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n    const queryCache = this.queryCache\n\n    const refetchFilters: RefetchQueryFilters = {\n      type: 'active',\n      ...filters,\n    }\n\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset()\n      })\n      return this.refetchQueries(refetchFilters, options)\n    })\n  }\n\n  cancelQueries(filters?: QueryFilters, options?: CancelOptions): Promise<void>\n  cancelQueries(\n    queryKey?: QueryKey,\n    filters?: QueryFilters,\n    options?: CancelOptions,\n  ): Promise<void>\n  cancelQueries(\n    arg1?: QueryKey | QueryFilters,\n    arg2?: QueryFilters | CancelOptions,\n    arg3?: CancelOptions,\n  ): Promise<void> {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3)\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true\n    }\n\n    const promises = notifyManager.batch(() =>\n      this.queryCache\n        .findAll(filters)\n        .map((query) => query.cancel(cancelOptions)),\n    )\n\n    return Promise.all(promises).then(noop).catch(noop)\n  }\n\n  invalidateQueries<TPageData = unknown>(\n    filters?: InvalidateQueryFilters<TPageData>,\n    options?: InvalidateOptions,\n  ): Promise<void>\n  invalidateQueries<TPageData = unknown>(\n    queryKey?: QueryKey,\n    filters?: InvalidateQueryFilters<TPageData>,\n    options?: InvalidateOptions,\n  ): Promise<void>\n  invalidateQueries(\n    arg1?: QueryKey | InvalidateQueryFilters,\n    arg2?: InvalidateQueryFilters | InvalidateOptions,\n    arg3?: InvalidateOptions,\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n\n    return notifyManager.batch(() => {\n      this.queryCache.findAll(filters).forEach((query) => {\n        query.invalidate()\n      })\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve()\n      }\n      const refetchFilters: RefetchQueryFilters = {\n        ...filters,\n        type: filters.refetchType ?? filters.type ?? 'active',\n      }\n      return this.refetchQueries(refetchFilters, options)\n    })\n  }\n\n  refetchQueries<TPageData = unknown>(\n    filters?: RefetchQueryFilters<TPageData>,\n    options?: RefetchOptions,\n  ): Promise<void>\n  refetchQueries<TPageData = unknown>(\n    queryKey?: QueryKey,\n    filters?: RefetchQueryFilters<TPageData>,\n    options?: RefetchOptions,\n  ): Promise<void>\n  refetchQueries(\n    arg1?: QueryKey | RefetchQueryFilters,\n    arg2?: RefetchQueryFilters | RefetchOptions,\n    arg3?: RefetchOptions,\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n\n    const promises = notifyManager.batch(() =>\n      this.queryCache\n        .findAll(filters)\n        .filter((query) => !query.isDisabled())\n        .map((query) =>\n          query.fetch(undefined, {\n            ...options,\n            cancelRefetch: options?.cancelRefetch ?? true,\n            meta: { refetchPage: filters.refetchPage },\n          }),\n        ),\n    )\n\n    let promise = Promise.all(promises).then(noop)\n\n    if (!options?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1: TQueryKey | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions)\n\n    // https://github.com/tannerlinsley/react-query/issues/652\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions)\n\n    return query.isStaleByTime(defaultedOptions.staleTime)\n      ? query.fetch(defaultedOptions)\n      : Promise.resolve(query.state.data as TData)\n  }\n\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1: TQueryKey | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void> {\n    return this.fetchQuery(arg1 as any, arg2 as any, arg3)\n      .then(noop)\n      .catch(noop)\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1:\n      | TQueryKey\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    parsedOptions.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData\n    >()\n    return this.fetchQuery(parsedOptions)\n  }\n\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1:\n      | TQueryKey\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void> {\n    return this.fetchInfiniteQuery(arg1 as any, arg2 as any, arg3)\n      .then(noop)\n      .catch(noop)\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    return this.mutationCache.resumePausedMutations()\n  }\n\n  getQueryCache(): QueryCache {\n    return this.queryCache\n  }\n\n  getMutationCache(): MutationCache {\n    return this.mutationCache\n  }\n\n  getLogger(): Logger {\n    return this.logger\n  }\n\n  getDefaultOptions(): DefaultOptions {\n    return this.defaultOptions\n  }\n\n  setDefaultOptions(options: DefaultOptions): void {\n    this.defaultOptions = options\n  }\n\n  setQueryDefaults(\n    queryKey: QueryKey,\n    options: QueryObserverOptions<unknown, any, any, any>,\n  ): void {\n    const result = this.queryDefaults.find(\n      (x) => hashQueryKey(queryKey) === hashQueryKey(x.queryKey),\n    )\n    if (result) {\n      result.defaultOptions = options\n    } else {\n      this.queryDefaults.push({ queryKey, defaultOptions: options })\n    }\n  }\n\n  getQueryDefaults(\n    queryKey?: QueryKey,\n  ): QueryObserverOptions<any, any, any, any, any> | undefined {\n    if (!queryKey) {\n      return undefined\n    }\n\n    // Get the first matching defaults\n    const firstMatchingDefaults = this.queryDefaults.find((x) =>\n      partialMatchKey(queryKey, x.queryKey),\n    )\n\n    // Additional checks and error in dev mode\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.queryDefaults.filter((x) =>\n        partialMatchKey(queryKey, x.queryKey),\n      )\n      // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\n          `[QueryClient] Several query defaults match with key '${JSON.stringify(\n            queryKey,\n          )}'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.`,\n        )\n      }\n    }\n\n    return firstMatchingDefaults?.defaultOptions\n  }\n\n  setMutationDefaults(\n    mutationKey: MutationKey,\n    options: MutationObserverOptions<any, any, any, any>,\n  ): void {\n    const result = this.mutationDefaults.find(\n      (x) => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey),\n    )\n    if (result) {\n      result.defaultOptions = options\n    } else {\n      this.mutationDefaults.push({ mutationKey, defaultOptions: options })\n    }\n  }\n\n  getMutationDefaults(\n    mutationKey?: MutationKey,\n  ): MutationObserverOptions<any, any, any, any> | undefined {\n    if (!mutationKey) {\n      return undefined\n    }\n\n    // Get the first matching defaults\n    const firstMatchingDefaults = this.mutationDefaults.find((x) =>\n      partialMatchKey(mutationKey, x.mutationKey),\n    )\n\n    // Additional checks and error in dev mode\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.mutationDefaults.filter((x) =>\n        partialMatchKey(mutationKey, x.mutationKey),\n      )\n      // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\n          `[QueryClient] Several mutation defaults match with key '${JSON.stringify(\n            mutationKey,\n          )}'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.`,\n        )\n      }\n    }\n\n    return firstMatchingDefaults?.defaultOptions\n  }\n\n  defaultQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey extends QueryKey,\n  >(\n    options?:\n      | QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>\n      | DefaultedQueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey\n        >,\n  ): DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > {\n    if (options?._defaulted) {\n      return options as DefaultedQueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryData,\n        TQueryKey\n      >\n    }\n\n    const defaultedOptions = {\n      ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options?.queryKey),\n      ...options,\n      _defaulted: true,\n    }\n\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(\n        defaultedOptions.queryKey,\n        defaultedOptions,\n      )\n    }\n\n    // dependent default values\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect =\n        defaultedOptions.networkMode !== 'always'\n    }\n    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense\n    }\n\n    return defaultedOptions as DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >\n  }\n\n  defaultMutationOptions<T extends MutationOptions<any, any, any, any>>(\n    options?: T,\n  ): T {\n    if (options?._defaulted) {\n      return options\n    }\n    return {\n      ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options?.mutationKey),\n      ...options,\n      _defaulted: true,\n    } as T\n  }\n\n  clear(): void {\n    this.queryCache.clear()\n    this.mutationCache.clear()\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
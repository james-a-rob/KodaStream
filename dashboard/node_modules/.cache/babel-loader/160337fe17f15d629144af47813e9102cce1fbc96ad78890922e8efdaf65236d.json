{"ast":null,"code":"import { hashQueryKeyByOptions, parseFilterArgs, matchQuery } from './utils.mjs';\nimport { Query } from './query.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { Subscribable } from './subscribable.mjs';\n\n// CLASS\nclass QueryCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.queries = [];\n    this.queriesMap = {};\n  }\n  build(client, options, state) {\n    var _options$queryHash;\n    const queryKey = options.queryKey;\n    const queryHash = (_options$queryHash = options.queryHash) != null ? _options$queryHash : hashQueryKeyByOptions(queryKey, options);\n    let query = this.get(queryHash);\n    if (!query) {\n      query = new Query({\n        cache: this,\n        logger: client.getLogger(),\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey)\n      });\n      this.add(query);\n    }\n    return query;\n  }\n  add(query) {\n    if (!this.queriesMap[query.queryHash]) {\n      this.queriesMap[query.queryHash] = query;\n      this.queries.push(query);\n      this.notify({\n        type: 'added',\n        query\n      });\n    }\n  }\n  remove(query) {\n    const queryInMap = this.queriesMap[query.queryHash];\n    if (queryInMap) {\n      query.destroy();\n      this.queries = this.queries.filter(x => x !== query);\n      if (queryInMap === query) {\n        delete this.queriesMap[query.queryHash];\n      }\n      this.notify({\n        type: 'removed',\n        query\n      });\n    }\n  }\n  clear() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        this.remove(query);\n      });\n    });\n  }\n  get(queryHash) {\n    return this.queriesMap[queryHash];\n  }\n  getAll() {\n    return this.queries;\n  }\n  find(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n    return this.queries.find(query => matchQuery(filters, query));\n  }\n  findAll(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    return Object.keys(filters).length > 0 ? this.queries.filter(query => matchQuery(filters, query)) : this.queries;\n  }\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(({\n        listener\n      }) => {\n        listener(event);\n      });\n    });\n  }\n  onFocus() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onFocus();\n      });\n    });\n  }\n  onOnline() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onOnline();\n      });\n    });\n  }\n}\nexport { QueryCache };","map":{"version":3,"names":["QueryCache","Subscribable","constructor","config","queries","queriesMap","build","client","options","state","_options$queryHash","queryKey","queryHash","hashQueryKeyByOptions","query","get","Query","cache","logger","getLogger","defaultQueryOptions","defaultOptions","getQueryDefaults","add","push","notify","type","remove","queryInMap","destroy","filter","x","clear","notifyManager","batch","forEach","getAll","find","arg1","arg2","filters","parseFilterArgs","exact","matchQuery","findAll","Object","keys","length","event","listeners","listener","onFocus","onOnline"],"sources":["/Users/jamesrobertson/Code/air/dashboard/node_modules/@tanstack/query-core/src/queryCache.ts"],"sourcesContent":["import { hashQueryKeyByOptions, matchQuery, parseFilterArgs } from './utils'\nimport { Query } from './query'\nimport { notifyManager } from './notifyManager'\nimport { Subscribable } from './subscribable'\nimport type { QueryFilters } from './utils'\nimport type { Action, QueryState } from './query'\nimport type { NotifyEvent, QueryKey, QueryOptions } from './types'\nimport type { QueryClient } from './queryClient'\nimport type { QueryObserver } from './queryObserver'\n\n// TYPES\n\ninterface QueryCacheConfig {\n  onError?: (error: unknown, query: Query<unknown, unknown, unknown>) => void\n  onSuccess?: (data: unknown, query: Query<unknown, unknown, unknown>) => void\n  onSettled?: (\n    data: unknown | undefined,\n    error: unknown | null,\n    query: Query<unknown, unknown, unknown>,\n  ) => void\n}\n\ninterface QueryHashMap {\n  [hash: string]: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryAdded extends NotifyEvent {\n  type: 'added'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryRemoved extends NotifyEvent {\n  type: 'removed'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryUpdated extends NotifyEvent {\n  type: 'updated'\n  query: Query<any, any, any, any>\n  action: Action<any, any>\n}\n\ninterface NotifyEventQueryObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverResultsUpdated extends NotifyEvent {\n  type: 'observerResultsUpdated'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\nexport type QueryCacheNotifyEvent =\n  | NotifyEventQueryAdded\n  | NotifyEventQueryRemoved\n  | NotifyEventQueryUpdated\n  | NotifyEventQueryObserverAdded\n  | NotifyEventQueryObserverRemoved\n  | NotifyEventQueryObserverResultsUpdated\n  | NotifyEventQueryObserverOptionsUpdated\n\ntype QueryCacheListener = (event: QueryCacheNotifyEvent) => void\n\n// CLASS\n\nexport class QueryCache extends Subscribable<QueryCacheListener> {\n  config: QueryCacheConfig\n\n  private queries: Query<any, any, any, any>[]\n  private queriesMap: QueryHashMap\n\n  constructor(config?: QueryCacheConfig) {\n    super()\n    this.config = config || {}\n    this.queries = []\n    this.queriesMap = {}\n  }\n\n  build<TQueryFnData, TError, TData, TQueryKey extends QueryKey>(\n    client: QueryClient,\n    options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    state?: QueryState<TData, TError>,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> {\n    const queryKey = options.queryKey!\n    const queryHash =\n      options.queryHash ?? hashQueryKeyByOptions(queryKey, options)\n    let query = this.get<TQueryFnData, TError, TData, TQueryKey>(queryHash)\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        logger: client.getLogger(),\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n      })\n      this.add(query)\n    }\n\n    return query\n  }\n\n  add(query: Query<any, any, any, any>): void {\n    if (!this.queriesMap[query.queryHash]) {\n      this.queriesMap[query.queryHash] = query\n      this.queries.push(query)\n      this.notify({\n        type: 'added',\n        query,\n      })\n    }\n  }\n\n  remove(query: Query<any, any, any, any>): void {\n    const queryInMap = this.queriesMap[query.queryHash]\n\n    if (queryInMap) {\n      query.destroy()\n\n      this.queries = this.queries.filter((x) => x !== query)\n\n      if (queryInMap === query) {\n        delete this.queriesMap[query.queryHash]\n      }\n\n      this.notify({ type: 'removed', query })\n    }\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.queries.forEach((query) => {\n        this.remove(query)\n      })\n    })\n  }\n\n  get<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryHash: string,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> | undefined {\n    return this.queriesMap[queryHash]\n  }\n\n  getAll(): Query[] {\n    return this.queries\n  }\n\n  find<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    arg1: QueryKey,\n    arg2?: QueryFilters,\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    const [filters] = parseFilterArgs(arg1, arg2)\n\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true\n    }\n\n    return this.queries.find((query) => matchQuery(filters, query))\n  }\n\n  findAll(queryKey?: QueryKey, filters?: QueryFilters): Query[]\n  findAll(filters?: QueryFilters): Query[]\n  findAll(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): Query[]\n  findAll(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): Query[] {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    return Object.keys(filters).length > 0\n      ? this.queries.filter((query) => matchQuery(filters, query))\n      : this.queries\n  }\n\n  notify(event: QueryCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(({ listener }) => {\n        listener(event)\n      })\n    })\n  }\n\n  onFocus(): void {\n    notifyManager.batch(() => {\n      this.queries.forEach((query) => {\n        query.onFocus()\n      })\n    })\n  }\n\n  onOnline(): void {\n    notifyManager.batch(() => {\n      this.queries.forEach((query) => {\n        query.onOnline()\n      })\n    })\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
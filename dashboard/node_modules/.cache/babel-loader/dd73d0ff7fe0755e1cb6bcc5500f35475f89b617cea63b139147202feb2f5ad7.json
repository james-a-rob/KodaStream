{"ast":null,"code":"// TYPES\n// UTILS\nconst isServer = typeof window === 'undefined' || 'Deno' in window;\nfunction noop() {\n  return undefined;\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === 'number' && value >= 0 && value !== Infinity;\n}\nfunction difference(array1, array2) {\n  return array1.filter(x => !array2.includes(x));\n}\nfunction replaceAt(array, index, value) {\n  const copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction parseQueryArgs(arg1, arg2, arg3) {\n  if (!isQueryKey(arg1)) {\n    return arg1;\n  }\n  if (typeof arg2 === 'function') {\n    return {\n      ...arg3,\n      queryKey: arg1,\n      queryFn: arg2\n    };\n  }\n  return {\n    ...arg2,\n    queryKey: arg1\n  };\n}\nfunction parseMutationArgs(arg1, arg2, arg3) {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return {\n        ...arg3,\n        mutationKey: arg1,\n        mutationFn: arg2\n      };\n    }\n    return {\n      ...arg2,\n      mutationKey: arg1\n    };\n  }\n  if (typeof arg1 === 'function') {\n    return {\n      ...arg2,\n      mutationFn: arg1\n    };\n  }\n  return {\n    ...arg1\n  };\n}\nfunction parseFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{\n    ...arg2,\n    queryKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction parseMutationFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{\n    ...arg2,\n    mutationKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n  if (type !== 'all') {\n    const isActive = query.isActive();\n    if (type === 'active' && !isActive) {\n      return false;\n    }\n    if (type === 'inactive' && isActive) {\n      return false;\n    }\n  }\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false;\n  }\n  if (typeof fetchStatus !== 'undefined' && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const {\n    exact,\n    fetching,\n    predicate,\n    mutationKey\n  } = filters;\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n    if (exact) {\n      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n  if (typeof fetching === 'boolean' && mutation.state.status === 'loading' !== fetching) {\n    return false;\n  }\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;\n  return hashFn(queryKey);\n}\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\n\nfunction hashQueryKey(queryKey) {\n  return JSON.stringify(queryKey, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n    result[key] = val[key];\n    return result;\n  }, {}) : val);\n}\n/**\n * Checks if key `b` partially matches with key `a`.\n */\n\nfunction partialMatchKey(a, b) {\n  return partialDeepEqual(a, b);\n}\n/**\n * Checks if `b` partially matches with `a`.\n */\n\nfunction partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n  return false;\n}\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\n\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n  const array = isPlainArray(a) && isPlainArray(b);\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aSize = array ? a.length : Object.keys(a).length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      copy[key] = replaceEqualDeep(a[key], b[key]);\n      if (copy[key] === a[key]) {\n        equalItems++;\n      }\n    }\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n  return b;\n}\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\n\nfunction shallowEqualObjects(a, b) {\n  if (a && !b || b && !a) {\n    return false;\n  }\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n} // Copied from: https://github.com/jonschlinkert/is-plain-object\n\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  } // If has modified constructor\n\n  const ctor = o.constructor;\n  if (typeof ctor === 'undefined') {\n    return true;\n  } // If has modified prototype\n\n  const prot = ctor.prototype;\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  } // If constructor does not have an Object-specific method\n\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  } // Most likely a plain Object\n\n  return true;\n}\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\nfunction isQueryKey(value) {\n  return Array.isArray(value);\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\nfunction sleep(timeout) {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout);\n  });\n}\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\n\nfunction scheduleMicrotask(callback) {\n  sleep(0).then(callback);\n}\nfunction getAbortController() {\n  if (typeof AbortController === 'function') {\n    return new AbortController();\n  }\n  return;\n}\nfunction replaceData(prevData, data, options) {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {\n    return prevData;\n  } else if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data);\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data);\n  }\n  return data;\n}\nexport { difference, functionalUpdate, getAbortController, hashQueryKey, hashQueryKeyByOptions, isError, isPlainArray, isPlainObject, isQueryKey, isServer, isValidTimeout, matchMutation, matchQuery, noop, parseFilterArgs, parseMutationArgs, parseMutationFilterArgs, parseQueryArgs, partialDeepEqual, partialMatchKey, replaceAt, replaceData, replaceEqualDeep, scheduleMicrotask, shallowEqualObjects, sleep, timeUntilStale };","map":{"version":3,"names":["isServer","window","noop","undefined","functionalUpdate","updater","input","isValidTimeout","value","Infinity","difference","array1","array2","filter","x","includes","replaceAt","array","index","copy","slice","timeUntilStale","updatedAt","staleTime","Math","max","Date","now","parseQueryArgs","arg1","arg2","arg3","isQueryKey","queryKey","queryFn","parseMutationArgs","mutationKey","mutationFn","parseFilterArgs","parseMutationFilterArgs","matchQuery","filters","query","type","exact","fetchStatus","predicate","stale","queryHash","hashQueryKeyByOptions","options","partialMatchKey","isActive","isStale","state","matchMutation","mutation","fetching","hashQueryKey","status","hashFn","queryKeyHashFn","JSON","stringify","_","val","isPlainObject","Object","keys","sort","reduce","result","key","a","b","partialDeepEqual","some","replaceEqualDeep","isPlainArray","aSize","length","bItems","bSize","equalItems","i","shallowEqualObjects","Array","isArray","o","hasObjectPrototype","ctor","constructor","prot","prototype","hasOwnProperty","toString","call","isError","Error","sleep","timeout","Promise","resolve","setTimeout","scheduleMicrotask","callback","then","getAbortController","AbortController","replaceData","prevData","data","isDataEqual","structuralSharing"],"sources":["/Users/jamesrobertson/Code/air/dashboard/node_modules/@tanstack/query-core/src/utils.ts"],"sourcesContent":["import type { Mutation } from './mutation'\nimport type { Query } from './query'\nimport type {\n  FetchStatus,\n  MutationFunction,\n  MutationKey,\n  MutationOptions,\n  QueryFunction,\n  QueryKey,\n  QueryOptions,\n} from './types'\n\n// TYPES\n\nexport interface QueryFilters {\n  /**\n   * Filter to active queries, inactive queries or all queries\n   */\n  type?: QueryTypeFilter\n  /**\n   * Match query key exactly\n   */\n  exact?: boolean\n  /**\n   * Include queries matching this predicate function\n   */\n  predicate?: (query: Query) => boolean\n  /**\n   * Include queries matching this query key\n   */\n  queryKey?: QueryKey\n  /**\n   * Include or exclude stale queries\n   */\n  stale?: boolean\n  /**\n   * Include queries matching their fetchStatus\n   */\n  fetchStatus?: FetchStatus\n}\n\nexport interface MutationFilters {\n  /**\n   * Match mutation key exactly\n   */\n  exact?: boolean\n  /**\n   * Include mutations matching this predicate function\n   */\n  predicate?: (mutation: Mutation<any, any, any>) => boolean\n  /**\n   * Include mutations matching this mutation key\n   */\n  mutationKey?: MutationKey\n  /**\n   * Include or exclude fetching mutations\n   */\n  fetching?: boolean\n}\n\nexport type DataUpdateFunction<TInput, TOutput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput> =\n  | TOutput\n  | DataUpdateFunction<TInput, TOutput>\n\nexport type QueryTypeFilter = 'all' | 'active' | 'inactive'\n\n// UTILS\n\nexport const isServer = typeof window === 'undefined' || 'Deno' in window\n\nexport function noop(): undefined {\n  return undefined\n}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput,\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as DataUpdateFunction<TInput, TOutput>)(input)\n    : updater\n}\n\nexport function isValidTimeout(value: unknown): value is number {\n  return typeof value === 'number' && value >= 0 && value !== Infinity\n}\n\nexport function difference<T>(array1: T[], array2: T[]): T[] {\n  return array1.filter((x) => !array2.includes(x))\n}\n\nexport function replaceAt<T>(array: T[], index: number, value: T): T[] {\n  const copy = array.slice(0)\n  copy[index] = value\n  return copy\n}\n\nexport function timeUntilStale(updatedAt: number, staleTime?: number): number {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0)\n}\n\nexport function parseQueryArgs<\n  TOptions extends QueryOptions<any, any, any, TQueryKey>,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1: TQueryKey | TOptions,\n  arg2?: QueryFunction<any, TQueryKey> | TOptions,\n  arg3?: TOptions,\n): TOptions {\n  if (!isQueryKey(arg1)) {\n    return arg1 as TOptions\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3, queryKey: arg1, queryFn: arg2 } as TOptions\n  }\n\n  return { ...arg2, queryKey: arg1 } as TOptions\n}\n\nexport function parseMutationArgs<\n  TOptions extends MutationOptions<any, any, any, any>,\n>(\n  arg1: MutationKey | MutationFunction<any, any> | TOptions,\n  arg2?: MutationFunction<any, any> | TOptions,\n  arg3?: TOptions,\n): TOptions {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3, mutationKey: arg1, mutationFn: arg2 } as TOptions\n    }\n    return { ...arg2, mutationKey: arg1 } as TOptions\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2, mutationFn: arg1 } as TOptions\n  }\n\n  return { ...arg1 } as TOptions\n}\n\nexport function parseFilterArgs<\n  TFilters extends QueryFilters,\n  TOptions = unknown,\n>(\n  arg1?: QueryKey | TFilters,\n  arg2?: TFilters | TOptions,\n  arg3?: TOptions,\n): [TFilters, TOptions | undefined] {\n  return (\n    isQueryKey(arg1) ? [{ ...arg2, queryKey: arg1 }, arg3] : [arg1 || {}, arg2]\n  ) as [TFilters, TOptions]\n}\n\nexport function parseMutationFilterArgs<\n  TFilters extends MutationFilters,\n  TOptions = unknown,\n>(\n  arg1?: QueryKey | TFilters,\n  arg2?: TFilters | TOptions,\n  arg3?: TOptions,\n): [TFilters, TOptions | undefined] {\n  return (\n    isQueryKey(arg1)\n      ? [{ ...arg2, mutationKey: arg1 }, arg3]\n      : [arg1 || {}, arg2]\n  ) as [TFilters, TOptions]\n}\n\nexport function matchQuery(\n  filters: QueryFilters,\n  query: Query<any, any, any, any>,\n): boolean {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale,\n  } = filters\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive()\n    if (type === 'active' && !isActive) {\n      return false\n    }\n    if (type === 'inactive' && isActive) {\n      return false\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false\n  }\n\n  if (\n    typeof fetchStatus !== 'undefined' &&\n    fetchStatus !== query.state.fetchStatus\n  ) {\n    return false\n  }\n\n  if (predicate && !predicate(query)) {\n    return false\n  }\n\n  return true\n}\n\nexport function matchMutation(\n  filters: MutationFilters,\n  mutation: Mutation<any, any>,\n): boolean {\n  const { exact, fetching, predicate, mutationKey } = filters\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false\n    }\n    if (exact) {\n      if (\n        hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)\n      ) {\n        return false\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false\n    }\n  }\n\n  if (\n    typeof fetching === 'boolean' &&\n    (mutation.state.status === 'loading') !== fetching\n  ) {\n    return false\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false\n  }\n\n  return true\n}\n\nexport function hashQueryKeyByOptions<TQueryKey extends QueryKey = QueryKey>(\n  queryKey: TQueryKey,\n  options?: QueryOptions<any, any, any, TQueryKey>,\n): string {\n  const hashFn = options?.queryKeyHashFn || hashQueryKey\n  return hashFn(queryKey)\n}\n\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\nexport function hashQueryKey(queryKey: QueryKey): string {\n  return JSON.stringify(queryKey, (_, val) =>\n    isPlainObject(val)\n      ? Object.keys(val)\n          .sort()\n          .reduce((result, key) => {\n            result[key] = val[key]\n            return result\n          }, {} as any)\n      : val,\n  )\n}\n\n/**\n * Checks if key `b` partially matches with key `a`.\n */\nexport function partialMatchKey(a: QueryKey, b: QueryKey): boolean {\n  return partialDeepEqual(a, b)\n}\n\n/**\n * Checks if `b` partially matches with `a`.\n */\nexport function partialDeepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some((key) => !partialDeepEqual(a[key], b[key]))\n  }\n\n  return false\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b)\n\n  if (array || (isPlainObject(a) && isPlainObject(b))) {\n    const aSize = array ? a.length : Object.keys(a).length\n    const bItems = array ? b : Object.keys(b)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      copy[key] = replaceEqualDeep(a[key], b[key])\n      if (copy[key] === a[key]) {\n        equalItems++\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy\n  }\n\n  return b\n}\n\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\nexport function shallowEqualObjects<T>(a: T, b: T): boolean {\n  if ((a && !b) || (b && !a)) {\n    return false\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function isPlainArray(value: unknown) {\n  return Array.isArray(value) && value.length === Object.keys(value).length\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function isQueryKey(value: unknown): value is QueryKey {\n  return Array.isArray(value)\n}\n\nexport function isError(value: any): value is Error {\n  return value instanceof Error\n}\n\nexport function sleep(timeout: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeout)\n  })\n}\n\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\nexport function scheduleMicrotask(callback: () => void) {\n  sleep(0).then(callback)\n}\n\nexport function getAbortController(): AbortController | undefined {\n  if (typeof AbortController === 'function') {\n    return new AbortController()\n  }\n  return\n}\n\nexport function replaceData<\n  TData,\n  TOptions extends QueryOptions<any, any, any, any>,\n>(prevData: TData | undefined, data: TData, options: TOptions): TData {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual?.(prevData, data)) {\n    return prevData as TData\n  } else if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data)\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data)\n  }\n  return data\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}